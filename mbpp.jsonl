[
{
    "code": "function [A, c, b, Eqin, MinMaxLP] = \n canonical2standard(A, c, b, Eqin, MinMaxLP) \n[m, n] = size(A); % size of matrix A \n for i = 1:m \n if Eqin(i) == -1 \n A = [A zeros(m, 1)]; \n A(i, n + 1) = 1; \n c = [c; 0]; \n Eqin(i) = 0; \n n = n + 1; \n end \n end \n end",
    "summary": "the function is an implementation of the transformation of an LP problem in its canonical form to its standard form"
 },
{
"code":"function g = conj(f)\n %CONJ  Complex conjugate of a BALLFUN.\n %   CONJ(F) is the complex conjugate of F.\n % Copyright 2019 by The University of Oxford and The Chebfun Developers.\n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @conj ); \n end",
"summary":"Complex conjugate of a BALLFUN."
},
{
"code":"function g = cos( f ) \n %COS   Cosine of a BALLFUN. \n %   COS(F) computes the cosine of F. \n % See also COSH, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @cos ); \n end",
"summary":"Cosine of a BALLFUN."
},
{
"code":"function g = cosh(f) \n %COSH   Hyperbolic cosine of a BALLFUN. \n %   COSH(F) computes the hyperbolic cosine of F. \n % \n % See also SINH, COS, SIN \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @cosh );  \n end",
"summary":"Hyperbolic cosine of a BALLFUN"
},
{
"code":"function g = exp(f) \n %EXP   Exponential of a BALLFUN. \n %   EXP(F) computes the exponential of the BALLFUN F. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @exp ); \n end",
"summary":"Exponential of a BALLFUN."
},
{
"code":"function v = grad(f) \n %GRAD Gradient of a BALLFUN in cartesian coordinates. \n %   GRAD(F) is the gradient of the BALLFUN F expressed in \n %   cartesian coordinates. \n %   This is shorthand for the command GRADIENT. \n % See also DIV, CURL \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n v = gradient(f); \n end",
"summary":"Gradient of a BALLFUN in cartesian coordinates."
},
{
"code":"function g = imag(f) \n %IMAG   Complex imaginary part of a BALLFUN. \n %   IMAG(F) is the imaginary part of F. \n % See also REAL. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @imag );  \n end",
"summary":" Complex imaginary part of a BALLFUN."
},
{
"code":"function I = integral(f) \n %INTEGRAL   Triple integral of a BALLFUN over its domain. \n %   I = INTEGRAL(F) returns the double definite integral of a BALLFUN. \n % See also SUM3. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n I = sum3(f); \n end",
"summary":"Triple integral of a BALLFUN over its domain."
},
{
"code":"function out = isempty( f ) \n %ISEMPTY   True for empty BALLFUN. \n %   ISEMPTY(F) returns 1 if F is an empty BALLFUN and 0 otherwise. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers . \n % See http://www.chebfun.org/ for Chebfun information. \n out = isempty( f.coeffs ); \n end",
"summary":" True for empty BALLFUN."
},
{ 
"code":"function b = isequal(f, g) \n %ISEQUAL Equality test for BALLFUN. \n %   ISEQUAL(F, G) returns 1 if F =G, \n %   returns 0 otherwise \n %   See also ISZERO. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n % Test if f = g \n b = iszero( f - g ); \n end",
"summary":"Equality test for BALLFUN.  "
},
{
"code":"function varargout = lap(varargin) \n %LAP   Laplacian of a BALLFUN. \n %   L = LAP(F) returns a BALLFUN representing the Laplacian of F. \n %   This is shorthand for LAPLACIAN(F). \n % See also BALLFUN/LAPLACIAN. \n % Copyright 2017 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n [varargout{1:nargout}] = laplacian(varargin{:}); \n end",
"summary":"returns a BALLFUN representing the Laplacian of F."
},
{
"code":"function g = log(f) \n %LOG   Natural logarithm of a BALLFUN. \n %   LOG(F) returns the natural logarithm of F. If F has any roots over the \n %   unit ball, then the representation is likely to be inaccurate. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n % Return the logarithm of the ballfun function f \n g = compose( f, @log ); \n end",
"summary":" Natural logarithm of a BALLFUN"
},
{
"code":"function s = mean(f, dim) \n %MEAN   Average or mean value of a BALLFUN in a specific direction. \n %   MEAN(F, DIM) where DIM is 1, 2 or 3 is the mean of F over r (radial direction), \n %   lambda (azimuthal direction) or theta (polar direction) respectively and \n %   and returns as its output a spherefun if DIM is 1 or a diskfun otherwise. \n % See also BALLFUN/MEAN2, BALLFUN/MEAN3. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n if ( nargin == 1) \n % Default to the r-direction: \n dim = 1; \n end \n % Compute the definite integral of f \n s = sum(f, dim); \n if dim == 1 \n % Mean in the r direction \n s = s*3; \n elseif dim == 2\n % Mean in the lambda direction \n s = s/(2*pi); \n elseif dim == 3 \n % Mean in the theta direction \n s = s/2; \n else \n error('CHEBFUN:BALLFUN:mean:dim', ... \n Unrecognized input.') \n end \n end",
"summary":"Average or mean value of a BALLFUN in a specific direction. "
},
{
"code":"function h = minus(f, g) \n %BALLFUN minus. \n %   F - G subtracts BALLFUNs F and G, or a scalar from a BALLFUN if either F or \n %   G is a scalar. \n %   H = MINUS(F, G) is called for the syntax 'F - G'. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n h = f + (-g); \n end",
"summary":" subtracts BALLFUNs F and G,"
},
{
"code":"function g = mrdivide(f,c) \n %/   Right scalar divide for BALLFUN objects. \n %   X = B/A or X = mrdivide(B, A) is equivalent to X = B./A. \n % See also MTIMES. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = f*(1/c); \n end",
"summary":"Right scalar divide for BALLFUN objects."
},
{
"code":"function g = power(f,n) \n %.^   BALLFUN power. \n %   F.^G returns a BALLFUN F to the scalar power G. \n %   H = POWER(F, G) is called for the syntax 'F .^ G'. \n % See also SQRT. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n n = ballfun( n ); \n g = compose(f, @power, n); \n end",
"summary":" F.^G returns a BALLFUN F to the scalar power G."
},
{
"code":"function g = real(f) \n %REAL Real part of a BALLFUN. \n %   REAL(F) is the real part of the BALLFUN F. \n % See also IMAG. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @real ); \n end",
"summary":"REAL(F) is the real part of the BALLFUN F."
},

{
"code":"function g = sin(f) \n %SIN  Sine of a BALLFUN. \n %   SIN(F) computes the sine of the BALLFUN F. \n % See also SINH, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sin ); \n end",
"summary":"computes the sine of the BALLFUN F."
},
{
"code":"function g = sinh(f) \n %SINH   Hyperbolic sine of a BALLFUN. \n %   SINH(F) computes the hyperbolic sine of the BALLFUN F. \n % See also SIN, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sinh ); \n end",
"summary":"  Hyperbolic sine of a BALLFUN."
},
{
"code":"function g = sqrt(f) \n %SQRT   Square root of a BALLFUN. \n %   SQRT(F) is the square root of a BALLFUN F. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sqrt ); \n end",
"summary":"Square root of a BALLFUN."
},
{
"code":"function g = tan(f) \n %TAN   Tangent of a BALLFUN. \n %   TAN(F) computes the tangent of the BALLFUN F. \n % See also TANH, SIN, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @tan ); \n end",
"summary":"Tangent of a BALLFUN."
},
{
"code":"function g = tanh(f) \n %TANH   Hyperbolic tangent of a BALLFUN. \n %   TANH(F) computes the hyperbolic tangent of the BALLFUN F. \n % See also TAN, SINH, COSH. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @tanh ); \n end",
"summary":"Hyperbolic tangent of a BALLFUN."
},
{
"code":"function f = uminus(f) \n %-   BALLFUN unary minus. \n %   -F negates the BALLFUN F. \n %   G = UMINUS(F) is called for the syntax '-F'. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n f.coeffs = -f.coeffs; \n end",
"summary":"BALLFUN unary minus."
},
{
"code":"function f = uplus(f) \n %+   BALLFUN unary plus. \n %   +F of a BALLFUN is F. \n %   G = UPLUS(F) is called for the syntax '+F'. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n end",
"summary":"BALLFUN unary plus."
},
{
"code":"function d = detperm(p) \n n = length(p); \n if isoctave(), P =   eye(n);  % Octave uses special representation \n else,          P = speye(n); \n end \n d = det(P(:,p)); \n end",
"summary":"computes the determinant (i.e., sign) D of the permutation"
},
{
"code":"function symm = chksymm(symm) \n symm = lower(symm); \n assert(strcmp(symm,'n') || strcmp(symm,'s') || strcmp(symm,'h') || ... \n strcmp(symm,'p'),'FLAM:chksymm:invalidSymm', ... \n 'Symmetry parameter must be one of ''N'', ''S'', ''H'', or ''P''.') \n end",
"summary":"Check symmetry parameter."
},
{
"code":"function trans = chktrans(trans) \n trans = lower(trans); \n assert(strcmp(trans,'n') || strcmp(trans,'t') || strcmp(trans,'c'), ... \n FLAM:chktrans:invalidTrans', ... \n 'Transpose parameter must be one of ''N'', ''T'', or ''C''.') \n end",
"summary":" Check transpose parameter."
},
{
"code":"function ld = logdet_ldl(D) \n idx = full(sum(D ~= 0)) == 1;  % find 1x1 blocks ... \n d = diag(D);                   % ... and compute determinant ... \n ld = sum(log(d(idx)));         % ... from corresponding diagonal \n idx = find(~idx);  % accumulate determinant for each 2x2 block \n for i = 1:2:length(idx), ld = ld + log(det(D(idx(i:i+1),idx(i:i+1)))); end \n end",
"summary":" Compute log-determinant of D factor from block LDL factorization"
},
{
"code":"function A = spaddv(A,I,J,V) \n n = numel(J); \n for j = 1:n, A{J(j)}(I) = A{J(j)}(I) + V(:,j); end \n end",
"summary":" Sparse matrix addition for sparse column cell array."
},
{
"code":"function S = spget(A,I,J) \n S = A(:,J); \n S = full(S(I,:)); \n end",
"summary":"Sparse matrix access."
},
{
"code":"function [I,J,nz] = sppush2(I,J,nz,i,j) \n N = length(I); \n n = numel(i); \n assert(length(J) == N && numel(j) == n,'FLAM:sppush2:sizeMismatch', ... \n Arrays I and J must have the same size.') \n nznew = nz + n; \n if N < nznew \n while N < nznew, N = 2*N; end  % exponentially increase capacity as needed \n e = zeros(N-length(I),1); \n I = [I; e]; \n J = [J; e]; \n end \n I(nz+(1:n)) = i; \n J(nz+(1:n)) = j; \n nz = nznew; \n end",
"summary":"Append to 2-array sparse matrix representation."
},
{
"code":"function [C,N,A] = tri3geom(V,F) \n % set default parameters \n if nargin < 2 || isempty(F), F = [1; 2; 3]; end \n % compute triangle information \n C = (V(:,F(1,:)) + V(:,F(2,:)) + V(:,F(3,:)))/3; \n V21 = V(:,F(2,:)) - V(:,F(1,:)); \n V32 = V(:,F(3,:)) - V(:,F(2,:)); \n N = cross(V21,V32); \n A = sqrt(sum(N.^2)); \n N = N./A; \n A = 0.5*A; \n end",
"summary":"Centroid, unit normal, and area of a triangle in 3D."
},
{
    "code": "function x=BackSub(U,b) \n % This function computes the vector $x$ by backward substitution. \n % We solve $Ux=b$, where $U$ is an $n \times n$ nonsingular upper triangular matrix \n % and $b$ is a known vector of the length $n$, finding the vector $x$. \n %% Compute x by backward substitution. \n s=size(U); \n n=s(1); \n x=zeros(n,1); \n %  $U(i,i)*x(i) = b(i) - \\sum_{j=i+1}^{n}$ \n x(n)=b(n)/U(n,n); \n for i=n-1:-1:1 \n x(i)=(b(i)-U(i,(i+1):n)*x((i+1):n))/U(i,i); \n end \n end",
    "summary": "This function computes the vector $x$ by backward substitution."
},
{
"code":"% ---------------------------------------- \n % Find all eigenvalues of the matrix A ion the input interval [a,b) \n % ---------------------------------------- \n % define size n of the  n-by-n matrix A \n n=5; \n % Generate the symmetric tridiagonal  matrix A \n A=randomTridiag(n); \n % Set bounds for the interval [a,b) in the algorithm and the tolerance \n a=-100;b=100; \n tol=0.000001; \n %Define functions for the worklist \n DeleteRowInWorklist=@(Worklist,linenr) ChangeRowInWorklist(Worklist,linenr,'delete'); \n InsertRowInWorklist=@(Worklist,LineToAdd)... \n ChangeRowInWorklist(Worklist,LineToAdd,'add'); \n % Set the info for the first worklist \n na=Negcount(A,a); \n nb=Negcount(A,b); \n Worklist=[]; \n %If no eigenvalues are found on the interval [a,b) then save an empty worklist \n if na ~= nb \n Worklist=InsertRowInWorklist(Worklist,[a,na,b,nb]); \n end \n while numel(Worklist) ~= 0 \n [Worklist, LineToWorkWith ]= DeleteRowInWorklist(Worklist,1); \n low=LineToWorkWith(1); \n n_low=LineToWorkWith(2); \n up=LineToWorkWith(3); \n n_up=LineToWorkWith(4); \n % if the upper and lower bounds are close enough we  print out this interval  \n if (up-low)< tol \n NrOfEigVal = n_up-n_low; \n fprintf('We have computed %3.0f eigenvalues in the interval [%4.4f,%4.4f) \n', ... \n NrOfEigVal,low,up); \n else \n % Perform the bisection step \n mid= (low+up)/2; \n n_mid= Negcount(A,mid); \n if n_mid > n_low \n Worklist = InsertRowInWorklist(Worklist,[low,n_low,mid,n_mid]); \n end \n if n_up>n_mid \n Worklist = InsertRowInWorklist(Worklist,[mid,n_mid,up,n_up]); \n end \n end \n end", 
"summary":"Find all eigenvalues of the matrix A ion the input interval [a,b)"
},
 {
    "code": "% ---------------------------------------- \n % Computes algorithm of Divide-and-Conquer: \n % eigenvalues will be roots of the secular equation and will lie \n % on the diagonal of the output matrix L. \n % In the output matrix Q will be corresponding eigenvectors. \n % ---------------------------------------- \n function [Q,L] = DivideandConq(T) \n % Compute size of input matrix T: \n [m,n] = size(T); \n % here we will divide the matrix \n m2 = floor(m/2); \n %if m=0 we shall return \n if m2 == 0 %1 by 1 \n Q = 1; L = T; \n return; \n %else we perform recursive computations \n else \n [T,T1,T2,bm,v] = formT(T,m2); \n %recursive computations \n [Q1,L1] = DivideandConq(T1); \n [Q2,L2] = DivideandConq(T2); \n %pick out the last and first columns of the transposes: \n Q1T = Q1'; \n Q2T = Q2'; \n u = [Q1T(:,end); Q2T(:,1)]; \n %Creating the D-matrix: \n D = zeros(n); \n D(1:m2,1:m2 ) = L1; \n D((m2+1):end,(m2+1):end) = L2; \n % The Q matrix (with Q1 and Q2 on the \"diagonals\") \n Q = zeros(n); \n Q(1:m2,1:m2) = Q1; \n Q((m2+1):end,(m2+1):end) = Q2; \n %Creating the matrix B, which determinant is the secular equation: \n % det B = f(\\lambda)=0 \n B = D+bm*u*u'; \n  % Compute eigenvalues as roots of the secular equation \n %  f(\\lambda)=0  using Newton's method \n eigs = NewtonMethod(D,bm,u); \n Q3 = zeros(m,n); \n % compute eigenvectors for corresponding eigenvalues \n for i = 1:length(eigs) \n Q3(:,i) = (D-eigs(i)*eye(m))\\u; \n Q3(:,i) = Q3(:,i)/norm(Q3(:,i)); \n end \n %Compute  eigenvectors of the original input matrix T \n Q = Q*Q3; \n % Present eigenvalues  of the original matrix input T \n %(they will be on diagonal) \n L = zeros(m,n); \n L(1:(m+1):end) = eigs; \n return; \n end \n end \n Compute T1, T2  constant bm  and the vector v \n %from the input matrix A. \n function [T,T1,T2,bm,v] = formT(A,m) \n T1 = A(1:m,1:m); \n T2 = A((m+1):end,(m+1):end); \n bm = A(m,m+1); \n T1(end) = T1(end)-bm; \n T2(1) = T2(1)-bm; \n v = zeros(size(A,1),1); \n v(m:m+1) = 1; \n T = zeros(size(A)); \n T(1:m,1:m) = T1; \n T((m+1):end,(m+1):end) = T2; \n end \n % compute eigenvalues in the secular equation \n % using the Newton's method \n function eigs = NewtonMethod(D,p,u) \n [m,n] = size(D); \n %The initial guess in  the Newton's method \n % will be the numbers d_i \n startingPoints = sort(diag(D)); \n %if p > 0 we have an eigenvalue on the right, else on the left \n if p >= 0 \n startingPoints = [startingPoints; startingPoints(end)+10000]; \n elseif p < 0 \n startingPoints = [startingPoints(1)-10000; startingPoints]; \n end \n eigs = zeros(m,1); \n % tolerance in Newton's method \n convCriteria = 1e-05; \n % step in the approximation of the derrivative \n % in Newton's method \n dx = 0.00001; \n %plot the secular equation \n X = linspace(-3,3,1000); \n for t = 1:1000 \n y(t) =SecularEqEval(D,p,u,X(t),m,n); \n end \n plot(X,y, 'LineWidth',2) \n axis([-3 3 -5 5]) \n legend('graph of the secular equation $f(\\lambda)=0$') \n %Start  Newton's method \n for i = 1:m \n %the starting value of lambda \n currentVal = (startingPoints(i)+startingPoints(i+1) )/ 2; \n % this value is used inthe stoppimg criterion below \n currentVal2 = inf; \n %  computed secular equation for \\lambda=currentVal \n fCurr = SecularEqEval(D,p,u,currentVal,m,n); \n rands = 0; \n k =0; \n j = 0; \n if  ~((startingPoints(i+1)-startingPoints(i)) < 0.0001) \n while ~(abs(fCurr) < convCriteria) \n %compute value of the function  dfApprox with small step dx to \n %approximate derivative \n fval2 = SecularEqEval(D,p,u,currentVal+dx,m,n); \n fval1 = SecularEqEval(D,p,u,currentVal,m,n); \n dfApprox = (fval2-fval1)/dx; \n % compute new value of  currentVal in Newton's method, \n % or perform one iteration in Newton's method \n currentVal = currentVal - fCurr/dfApprox; \n % check: if we are  outside of the current range, reinput inside: \n if currentVal <= startingPoints(i) \n currentVal= startingPoints(i)+0.0001; \n k=k+1; \n elseif currentVal >= startingPoints(i+1); \n currentVal= startingPoints(i+1)-0.0001; \n k=k+1; \n elseif dfApprox == Inf || dfApprox == -Inf \n currentVal= startingPoints(i) + ... \n rand*(startingPoints(i+1)-startingPoints(i)); \n rands = rands+1; \n end \n j=j+1; \n fCurr = SecularEqEval(D,p,u,currentVal,m,n); \n if k > 10 || j > 50; \n tempVec = [startingPoints(i),startingPoints(i+1)]; \n [val,ind] = min(abs([startingPoints(i),startingPoints(i+1)]-currentVal)); \n if ind == 1 \n currentVal = tempVec(ind)+0.00001; \n else \n currentVal = tempVec(ind)-0.00001; \n end \n break; \n elseif currentVal2 == currentVal || rands > 5 || isnan(currentVal) || isnan(fCurr) \n currentVal = currentVal2; \n break; \n end \n %save last value: \n currentVal2 = currentVal; \n end \n end \n %assigning eigenvalue in the right order \n eigs(i) = currentVal; \n end \n end \n % evaluate the  secular equation in Newton's method for the computed \n % eigenvalue x \n function fVal = SecularEqEval(D,p,u,x,m,n) \n fVal = 1+p*u'*inv((D-x*eye(m,n)))*u; \n end \n ",
    "summary": "Computes algorithm of Divide-and-Conquer:"
  },
{
"code":"function A=DiscretePoisson2D(n) \n % The function for 2D discretization  of the Laplace operator with sign minus: - laplace \n % Input parameters: \n % n -  number of inner nodes, which is assumed to be the same in both \n % the x_1- and x_2 directions. \n A = zeros(n*n,n*n); \n % Main diagonal \n for i=1:n*n \n A(i,i)=4; \n end \n % 1st and 2nd off-diagonals \n for k=1:n % go through block 1 to n \n for i=1:(n-1) \n A(n*(k-1)+i,n*(k-1)+i+1)=-1; % \n A(n*(k-1)+i+1,n*(k-1)+i)=-1; \n end \n end \n % 3rd and 4th off-diagonals \n for i=1:n*(n-1) \n A(i,i+n)=-1; \n A(i+n,i)=-1; \n end \n end",
"summary":"The function for 2D discretization  of the Laplace operator with sign minus: - laplace"
},
{
    "code": "function x=ForwSub(L,b) \n % This function computes the vector $x$, of length $n$, \n % given $Lx=b$ where $L$ is an $n \\times n$ nonsingular lower triangular matrix \n % and $b$ is a known vector of length $n$, by using forward substitution. \n %% Compute $x$ by forward substitution. \n s=size(L); \n n=s(1); \n x=zeros(n,1); \n % $L(i,i)*x(i)=b(i) - \\sum_{j=1}^{i-1}$ \n % First, set $x(i)=b(i)$, then subtract the known values. \n % Lastly, divide by diagonal entry $L(i,i)$ \n x(1)=b(1)/L(1,1); \n for i=2:n \n x(i)=(b(i)-L(i,1:(i-1))*x(1:(i-1)))/L(i,i); \n end \n end",
    "summary": "This function computes the vector $x$, of length $n$"
  },
{
"code":" \n % ---------------------------------------- \n % Run Hager's algorithm. \n % ---------------------------------------- \n function [LowerBound] = HagersAlg(B) \n x=(1/length(B))*ones(length(B),1); \n iter=1; \n while iter < 1000 \n w=B*x; xi=sign(w); z = B'*xi; \n if max(abs(z)) <= z'*x \n break \n else \n x= (max(abs(z))== abs(z)); \n end \n iter = iter + 1; \n end \n LowerBound = norm(w,1); \n end",
"summary":"Run Hager's algorithm."
},
{
"code":"function [bc] = mbinocof(n,k) \n if n<k \n   error('error - n<k!') \n elseif mod(n,1)~=0 || mod(k,1)~=0 \n error('error - input values are not integers') \n end \n %% the works \n if ~isa(n,'double'),n=double(n);end \n if ~isa(k,'double'),k=double(k);end \n bc = factorial(n) / (factorial(k)*factorial(n-k));",
"summary":"computes the binomial coefficient for values of n up to 170"
},
{
"code":"function AD = adjoint(A) \n %<<1/17/96   last updated>> \n %ADJOINT  Compute the classical adjoint of a square matrix A. \n % If A is not square an empty matrix is returned. \n % *** This routine should only be used by students to \n check adjoint computations and should not be used as \n % part of a routine to compute inverses. See invert or inv. \n % Use in the form   ==>  adjoint(A)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [m,n]=size(A); \n AD=[]; \n if m ~= n, return, end \n for ki=1:n \n for kj = 1:n \n AD(ki,kj) = (-1)^(ki+kj)*det(A([1:ki-1 ki+1:n],[1:kj-1 kj+1:n])); \n end \n end \n AD=AD'; \n end \n end \n AD=AD'; \n ",
"summary":"Compute the classical adjoint of a square matrix A."
},
{
"code":"function v=blkmat(m,n) \n %last updated 1/17/96 \n %BLKMAT  Generate a matrix of blanks of size m by n. \n %        Use in the form   ==>  blkmat(m,n)   <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %         Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n v=[]; \n for i=1:m \n v=[v;blanks(n)]; \n end",
"summary":"Generate a matrix of blanks of size m by n."
},
{
"code":"function val = cofactor(i,j,A)            %<<1/17/96   last updated>> \n %COFACTOR Computes the (i,j)-cofactor of matrix A. \n %If A is not sqaure an error message is displayed. \n % *** This routine should only be used by students to \n % check cofactor computations. \n % Use in the form  ==>  cofactor(i,j,A)  <== \n %% By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n blk=setstr(219); \n [m,n]=size(A); \n if m ~= n, \n disp([[blk blk blk] ['Error: matrix is not square.']]) \n return \n end \n %range check on i and j \n if i==abs(i) & j==abs(j) & i==fix(i) & j==fix(j) \n disp(' '); \n else \n disp([[blk blk blk] ['Error: indices not positive or not integer.']]) \n return \n end \n if i>n | j>n | i==0 | j==0 \n disp([[blk blk blk] ['Error: indices out of range.']]) \n return \n end \n val = (-1)^(i+j)*det(A([1:i-1 i+1:n],[1:j-1 j+1:n])); \n ",
"summary":"Computes the (i,j)-cofactor of matrix A."
},
{
"code":"function v=crossprd(x,y)                       %last updated 1/26/96 \n %CROSSPRD  Compute the cross product of vectors x and y in 3-space. \n % The output is a vector orthogonal to both of the original \n %  vectors x and y. The output is returned as a row matrix \n %       with 3 components [v1 v2 v3] which is interpreted as \n % v1*i + v2*j + v3*k \n % where i, j, and k are the unit vectors in the x, y, and z \n %       directions respectively. \n % Use in the form   ==>   v = crossprd(x,y)   <== \n % By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [mx nx]=size(x);[my ny]=size(y); \n blk=setstr(219); \n er='Error in Cross: size of input vector is not appropriate.'; \n if mx*nx~=3 | my*ny~=3 \n disp([blk blk blk er]) \n return \n end \n v=[x(2)*y(3)-x(3)*y(2) x(3)*y(1)-x(1)*y(3) x(1)*y(2)-x(2)*y(1)];",
"summary":"Compute the cross product of vectors x and y in 3-space."
},
{
"code":"function v=dot(x,y)                         %last updated 5/27/92 \n %DOT   The dot product of two n-vectors x and y is computed. \n %      The vectors can be either rows, columns, or matrices \n %      of the same size. \n %      Use in the form \n %  --->  dot(x,y)  <--- \n %By: David R. Hill, Math. Dept., Temple University \n %    Philadelphia, Pa. 19122 \n blk=setstr(219); \n er='Error in dot: arguments not of same size.'; \n [mx nx]=size(x);[my ny]=size(y); \n if (mx*nx ~= max([mx nx])) | (my*ny ~= max([my ny])) \n %check if one is a row and one a column \n % if not check for same size \n if (mx == my) & (nx == ny) \n %things are same size but not rows or columns \n else \n disp([blk blk blk er]) \n return \n end \n end \n x=x(:);y=y(:); \n v=x'*y; \n  ",
"summary":"the dot product of two n-vectors x and y is computed."
},
{
"code":"function v=dotprod(x,y)                         %last updated 1/17/96 \n %DOTPROD   The dot product of two n-vectors x and y is computed. \n %          The vectors can be either rows, columns, or matrices \n %          of the same size. For complex vectors the dot product \n %          of x and y is compted as the conjugate transpose of  \n %          the first times the second. \n %      Use in the form  ==>  dotprod(x,y)  <== \n %  By: David R. Hill, Math Dept, Temple University, \n %Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n %Note: this routine varies from MATLAB's dot command in \n %      how complex vectors are handled and how rectangular \n %      matrices are handled. \n blk=setstr(219); \n er='Error in dotprod: arguments not of same size.'; \n [mx nx]=size(x);[my ny]=size(y); \n if (mx*nx ~= max([mx nx])) | (my*ny ~= max([my ny])) \n %check if one is a row and one a column \n % if not check for same size \n if (mx == my) & (nx == ny) \n %things are same size but not rows or columns \n else \n disp([blk blk blk er]) \n return \n end \n end \n x=x(:);y=y(:); \n v=x'*y; \n ",
"summary":" The dot product of two n-vectors x and y is computed."
},
{
"code":"function AD = adjoint(A)       %<<1/17/96   last updated>> \n %ADJOINT  Compute the classical adjoint of a square matrix A. \n %         If A is not square an empty matrix is returned. \n *** This routine should only be used by students to \n %check adjoint computations and should not be used as \n %         part of a routine to compute inverses. See invert or inv. \n %         Use in the form   ==>  adjoint(A)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %         Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [m,n]=size(A); \n AD=[]; \n if m ~= n, return, end \n for ki=1:n \n for kj = 1:n \n AD(ki,kj) = (-1)^(ki+kj)*det(A([1:ki-1 ki+1:n],[1:kj-1 kj+1:n])); \n end \n end \n AD=AD'; \n end \n end \n AD=AD'; \n ",
"summary":" Compute the classical adjoint of a square matrix A."
},

{
"code":"function y = bksub(A,b)                     %last updated 1/17/96 \n %BKSUB   Perform back substitution on upper triangular \n %system Ax = b.  If A is not square, upper \n %triangular and nonsingular an error message is \n % displayed. In case of an error the solution returned is \n % all zeros. \n %   Use in the form ==> bksub(A,b)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n if (size(A)==size(A') & all(all(A==triu(A))) & abs(prod(diag(A))) > eps) \n n=length(b); \n x=zeros(n,1); \n for j=n:-1:1 \n x(j)=(b(j)-A(j,:)*x)/A(j,j); \n end \n y=x; \n else \n disp('Error in function backsub.') \n disp('Coefficient matrix not square,') \n disp('not upper triangular, or is singular.') \n return \n end",
"summary":"Perform back substitution on upper triangular"
},
{
"code":"function v=blkmat(m,n)                    %last updated 1/17/96 \n %BLKMAT  Generate a matrix of blanks of size m by n. \n % Use in the form   ==>  blkmat(m,n)   <== \n % By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n v=[]; \n for i=1:m \n v=[v;blanks(n)]; \n end",
"summary":"Generate a matrix of blanks of size m by n."
},
{
"code":"function v=crossprd(x,y) \n [mx nx]=size(x);[my ny]=size(y); \n blk=setstr(219); \n er='Error in Cross: size of input vector is not appropriate.'; \n if mx*nx~=3 | my*ny~=3 \n disp([blk blk blk er]) \n return \n end \n v=[x(2)*y(3)-x(3)*y(2) x(3)*y(1)-x(1)*y(3) x(1)*y(2)-x(2)*y(1)];",
"summary":"Compute the cross product of vectors x and y in 3-space."
},
{
"code":"function B = cmult(A,i,r) \n B=A; \n B(:,i)=r*B(:,i);",
"summary":"Multiplies i-th column of A by r."
},
{
"code":"function B=colop(A,i,j,r) \n B=A; \n B(:,i)=B(:,i)+r*B(:,j);",
"summary":"Adds r times j-th column of A to i-th column."
},
{
"code":"function B = cperm(A,i,j) \n B=A; \n c=B(:,i);B(:,i)= B(:,j);B(:,j)=c; ",
"summary":"Interchanges i-th and j-th columns of matrix."
},
{
"code":"function B = mult(A,i,r) \n B=A;B(i,:)=r*B(i,:); ",
"summary":"Multiplies the i-th row by r."
},
{
"code":"function v = nullt(A) \n [m,n]=size(A); \n b=zeros(m,1); \n [v0,v1]=lsolve(A,b); \n v=v1; \n ",
"summary":"Finds null space of matrix using lsolve."
},
{
"code":"function addvec(v,w) \n v=v(:);     w=w(:); \n if (length(v)~=2) | (length(w)~=2) \n   error('Both v and w must be vectors of length two') \n end \n x = v + w; \n hold off \n clg \n plot([0 v(1)],[0, v(2)],'-',... \n [0 w(1)],[0, w(2)],'-',... \n [0 x(1)],[0, x(2)],'-') \n hold on \n text(v(1),v(2),'v') \n text(w(1),w(2),'w') \n text(x(1),x(2),'v+w') \n plot([w(1) x(1)],[w(2) x(2)],':') \n plot([v(1) x(1)],[v(2) x(2)],':') \n hold off ",
"summary":" Illustrate the sum v + w of 2-dimensional vectors."
},
{
"code":"function C = cofactor(A,i,j) \n if nargin == 3 \n M = A; \n M(i,:) = []; \n M(:,j) = []; \n C = (-1)^(i+j)*det(M); \n else \n [n,n] = size(A); \n for i = 1:n \n for j = 1:n \n C(i,j) = cofactor(A,i,j); \n end \n end \n end ",
"summary":"Cofactors and the cofactor matrix."
},
{
"code":"function cosine \n clc \n disp('This code illustrates the cosine formula and dot products') \n disp('found on p. 16 of G. Strang, 'Introduction to Linear Algebra.') \n clg \n axis([-10 10 -10 10]);axis('square') \n plot(0,0); hold on \n  axis([-10 10 -10 10]);axis('square') \n button = 1; \n fprintf('\n\n') \n disp('OPEN A FIGURE WINDOW') \n disp('Click at two points on the plot with the left button.') \n disp(' ') \n disp('Press any other key or button twice to exit.') \n [x,y,button]=ginput(2); \n clc \n while button==1 \n u=[x(1);y(1)]; \n  v=[x(2);y(2)]; \n plot([0 u(1)],[0 u(2)],'-',[0 v(1)],[0 v(2)],'-') \n text(u(1),u(2),'u') \n text(v(1),v(2),'v') \n axis([-10 10 -10 10]);axis('square') \n fprintf('\n\nThe cosine of the angle between the two vectors is\n') \n cosine = u'*v/(norm(u)*norm(v)); \n fprintf('cosine = u''*v/(norm(u)*norm(v)) = %g\n\n',cosine) \n disp('The angle between the two vectors in radians is') \n fprintf('acos(cosine) = %g\n\n',acos(cosine)) \n disp('The angle between the two vectors in degrees is') \n fprintf('180*acos(cosine)/pi = %g\n\n',180*acos(cosine)/pi) \n pause(3) \n disp('Click twice on the plot with the left button.') \n disp('Press any other key or button twice to exit.') \n [x,y,button]=ginput(2); \n clc \n clg \n axis([-10 10 -10 10]);axis('square') \n plot(0,0); hold on \n axis([-10 10 -10 10]);axis('square') ",
"summary":"Illustrates cosine formula and dot products."
},
{
"code":"function x = cramer(A,b) \n if det(A) == 0 \n error('Matrix is singular') \n end \n [n,n] = size(A); \n for j = 1:n \n B = A; \n B(:,j) = b; \n x(j) = det(B)/det(A); \n end \n x = x'; ",
"summary":"Solve linear system by Cramer's Rule."
},
{
"code":"function det = determ(A) \n [P,L,U,sign] = splu(A); \n det = sign*prod(diag(U));",
"summary":"computes the determinant of the square matrix A"
},
{
"code":"function eigen(A) \n disp(' ') \n disp('The trace and determinant are:') \n t = trace(A) \n d = det(A) \n disp(' ') \n disp('det(e*I-A) is :') \n disp(poly2str(poly(A),'e')) \n [S,LAMBDA] = eig(A); \n disp(' ') \n disp('The matrix of eigenvalues is: ') \n LAMBDA \n disp(' ') \n disp('The matrix of unit eigenvectors is: ') \n S \n ",
"summary":"Describe eigenvalues and eigenvectors."
},
{
"code":"function eigen2(a) \n d = a(1,1)*a(2,2) - a(1,2)*a(2,1); \n t = a(1,1) + a(2,2); \n e1 = (t + sqrt(t^2 - 4*d))/2; \n e2 = (t - sqrt(t^2 - 4*d))/2; \n if a(1,2) ~= 0 \n x1 = [a(1,2); e1-a(1,1)]; \n x2 = [a(1,2); e2-a(1,1)]; \n elseif a(2,1) ~= 0 \n x1 = [e1-a(2,2); a(2,1)]; \n x2 = [e2-a(2,2); a(2,1)]; \n else \n x1 = [1; 0]; \n x2 = [0; 1]; \n end \n disp(' ') \n disp('For this matrix, the polynomial whose roots are the eigenvalues is:') \n disp(['   e^2 - ' num2str(t) '*e + ' num2str(d) ' = 0']) \n disp(' ') \n disp('The first eigenvalue and eigenvector are:') \n e1 \n x1 \n disp(' ') \n disp('The second eigenvalue and eigenvector are:') \n e2 \n x2",
"summary":"Two by two eigenvalues and eigenvectors."
},

{
"code":"pause % Strike any key to continue \n clc \n A = [ 1      0    0.005    3 ]; \n v = [1      0 ]; \n pause(3) \n power(A,v,10); \n % Actual eigenvalues of A \n eig(A) \n % The method converged \n pause % Strike any key to continue \n clc \n A = [ 1       0    0.005  -1.05 ]; \n v = [1  0 ]; \n pause(3) \n power(A,v,10); \n [V,D] = eig(A) \n pause % Strike any key to continue \n clc \n A = [ 1   0 \n       0  -1 ];\n v = [1 \n      1 ]; \n pause(3) \n power(A,v,10); \n eig(A) \n pause % Strike any key to continue \n clc \n c = cos(.2); \n s = sin(.2); \n A = [ c  s  -s  c ]; \n v = [1  0 ]; \n pause(3) \n power(A,v,30); \n eig(A) \n echo off \n ",
"summary":"demonstrates the power method of finding the dominant eigenvalue"
},
{
"code":"function y = fastfour(x) \n n = length(x); \n i = sqrt(-1); \n omega = exp(-2*pi*i/n); \n if rem(n,2) == 0 \n k = (0:n/2-1)'; \n w = omega .^ k; \n u = fastfour(x(1:2:n-1)); \n v = w.*fastfour(x(2:2:n)); \n y = [u+v; u-v]; \n else \n j = 0:n-1; \n k = j'; \n F = omega .^ (k*j); \n y = F*x; \n end ",
"summary":"omputes the same finite Fourier transform as FFT(x)"
},
{
"code":"function [k,p] = findpiv(A,k,p,tol) \n [m,n] = size(A); \n r = find(abs(A(:))>tol); \n if isempty(r), return, end \n r = r(1); \n j = fix((r-1)/m)+1; \n p = p+j-1; \n k = k+r-(j-1)*m-1;",
"summary":"find a pivot for Gaussian elimination."
},
{
"code":"function X = inverse(A) \n [n,n] = size(A); \n I = eye(n,n); \n R = ref([A I]); \n X = R(:,n+1:n+n); ",
"summary":"Matrix inverse by Gauss Jordan elimination"
},
{
"code":"function s = permdet(p) \n n = length(p); \n I = eye(n); \n s = determ(I(p,:));",
"summary":"Determinant of a permutation."
},
{
"code":"function plot2d(X) \n x = X(1,:)'; \n y = X(2,:)'; \n plot(x,y,'c5o',x,y,'c6-'); \n axis([-10 10 -10 10]) \n axis('square') ",
"summary":"Two dimensional plot."
},
{
"code":"function p = randperm(n) \n [ignore,p] = sort(rand(1,n)); ",
"summary":"Random permutation."
},
{
"code":"function rats(A) \n tol = 1.e-6; \n A = A .* (abs(A)>tol); \n disp(' '); \n v = version; \n if v(1) == '4' \n f = get(0,'format'); \n format rat \n disp(A) \n format(f); \n else \n disp(rat(A,'s')) \n end \n disp(' ');",
"summary":"Print in rational form."
},
{
"code":"function s = signperm(p) \n n = length(p); \n s = 1; \n for j = 1:n \n k = find(p == j); \n if k ~= j \n p([k,j]) = p([j,k]); \n s = -s; \n end \n end ",
"summary":"Sign of a permutation."
},
{
"code":"function I = MutualInformation(X,Y); \n if (size(X,2) > 1)  \n I = JointEntropy(X) + Entropy(Y) - JointEntropy([X Y]); \n else \n I = Entropy(X) + Entropy(Y) - JointEntropy([X Y]); \n end",
"summary":"returns mutual information (in bits) of the 'X' and 'Y'"
},
{
"code":"function alpha = circ_ang2rad(alpha) \n alpha = alpha * pi /180;",
"summary":"converts values in degree to radians"
},
{
"code":"function alpha = circ_axial(alpha, p) \n if nargin < 2 \n p = 1; \n end \n alpha = mod(alpha*p,2*pi); ",
"summary":" Transforms p-axial data to a common scale."
},
{
"code":"function [r mu] = circ_axialmean(alphas, m, dim) \n if nargin < 3 \n dim = 1; \n end \n if nargin < 2 || isempty(m) \n m = 1; \n end \n zbarm = mean(exp(1i*alphas*m),dim); \n r = abs(zbarm); \n mu = angle(zbarm)/m;",
"summary":"Computes the mean direction for circular data with axial "
},
{
"code":"function [cid, alpha, mu] = circ_clust(alpha, numclust, disp) \n if nargin < 2, numclust = 5; end; \n if nargin < 3, disp = 0; end \n if nargin < 1 \n n = 20; \n alpha = 2*pi*rand(n,1)-pi; \n numclust = 4; \n disp = 1; \n end; \n n = length(alpha); \n if n < numclust, error('Not enough data for clusters.'), end \n cid = (1:n)'; \n num_unique = length(unique(cid)); \n num_clusters_wanted = numclust; \n while(num_unique > num_clusters_wanted) \n mu = NaN(n,1); \n for j=1:n \n if sum(cid==j)>0 \n mu(j) = circ_mean(alpha(cid==j)'); \n end \n end \n mudist = abs(circ_dist2(mu)); \n mindist = min(mudist(tril(ones(size(mudist)),-1)==1)); \n [row, col] = find(mudist==mindist); \n cid(cid==max(row)) = min(col); \n num_unique = length(unique(cid)); \n end \n cid2 = cid; \n uniquecids = unique(cid); \n for j=1:length(uniquecids) \n cid(cid2==uniquecids(j)) = j; \n end \n mu = NaN(num_unique,1); \n r = NaN(num_unique,1); \n for j=1:num_unique \n if sum(cid==j)>0 \n mu(j) = circ_mean(alpha(cid==j)'); \n r(j) = circ_r(alpha(cid==j)'); \n end \n end \n if disp \n z2 = exp(1i*alpha); \n plotColor(real(z2), imag(z2), cid, 2) \n zmu = r.*exp(1i*mu); \n plotColor(real(zmu), imag(zmu), 1:num_unique, 2, '*', 10, 1) \n     axis square \n set(gca, 'XLim', [-1, 1]); \n set(gca, 'YLim', [-1, 1]); \n end \n function plotColor(x, y, c, varargin) \n if nargin < 4 \n figurenum = 1; \n else \n figurenum = varargin{1}; \n end \n if nargin < 5 \n pstring = '.'; \n else \n pstring = varargin{2}; \n end \n if nargin < 6 \n ms = 10; \n else \n ms = varargin{3}; \n end \n if nargin < 7 \n overlay = 0; \n else \n overlay = varargin{4};  \n end \n csmall = unique(c); \n figure(figurenum); \n if ~overlay, close(figurenum); end \n  figure(figurenum); \n colors={'y', 'b', 'r', 'g', 'c', 'k', 'm'}; \n hold on; \n for j=1:length(csmall); \n ci = (c == csmall(j)); \n plot(x(ci), y(ci), strcat(pstring, colors{mod(j, length(colors))+1}), 'MarkerSize', ms); \n end \n if ~overlay, hold off; end \n figure(figurenum)",
"summary":" Performs a simple agglomerative clustering of angular data."
},
{
"code":"function [rho pval] = circ_corrcl(alpha, x) \n if size(alpha,2) > size(alpha,1) \n alpha = alpha'; \n end \n if size(x,2) > size(x,1) \n x = x'; \n end \n if length(alpha)~=length(x) \n error('Input dimensions do not match.') \n end \n n = length(alpha); \n rxs = corr(x,sin(alpha)); \n rxc = corr(x,cos(alpha)); \n rcs = corr(sin(alpha),cos(alpha)); \n rho = sqrt((rxc^2 + rxs^2 - 2*rxc*rxs*rcs)/(1-rcs^2)); \n pval = 1 - chi2cdf(n*rho^2,2); ",
"summary":"Correlation coefficient between one circular and one linear random"
},

{
"code":"function r =  circ_dist(x,y) \n if size(x,1)~=size(y,1) && size(x,2)~=size(y,2) && length(y)~=1 \n error('Input dimensions do not match.') \n end \n r = angle(exp(1i*x)./exp(1i*y));",
"summary":" Pairwise difference x_i-y_i around the circle computed efficiently."
},
{
  "code": "function [mu, ul, ll] = circ_mean(alpha, w, dim)\nif nargin < 3\n    dim = 1;\nend\nif nargin < 2 || isempty(w)\n    w = ones(size(alpha));\nelse\n    if size(w, 2) ~= size(alpha, 2) || size(w, 1) ~= size(alpha, 1)\n        error('Input dimensions do not match');\n    end\nend\nr = sum(w .* exp(1i * alpha), dim);\nmu = angle(r);\nif nargout > 1\n    t = circ_confmean(alpha, 0.05, w, [], dim);\n    ul = mu + t;\n    ll = mu - t;\nend",
  "summary": "Computes the mean direction for circular data."
},
{
"code":"function med = circ_median(alpha,dim) \n if nargin < 2 \n dim = 1; \n end \n M = size(alpha); \n med = NaN(M(3-dim),1); \n for i=1:M(3-dim) \n if dim == 2 \n beta = alpha(i,:)'; \n elseif dim ==1 \n beta = alpha(:,i); \n else \n error('circ_median only works along first two dimensions') \n end \n beta = mod(beta,2*pi); \n n = size(beta,1); \n dd = circ_dist2(beta,beta); \n m1 = sum(dd>=0,1); \n m2 = sum(dd<=0,1); \n dm = abs(m1-m2); \n if mod(n,2)==1 \n [m idx] = min(dm); \n else \n m = min(dm); \n idx = find(dm==m,2); \n end \n if m > 1 \n warning('Ties detected.') %#ok<WNTAG> \n end \n md = circ_mean(beta(idx)); \n if abs(circ_dist(circ_mean(beta),md)) > abs(circ_dist(circ_mean(beta),md+pi)) \n md = mod(md+pi,2*pi); \n end \n med(i) = md; \n end \n if dim == 2 \n med = med'; \n end",
"summary":" Computes the median direction for circular data."
},
{
"code":"function alpha = circ_rad2ang(alpha) \n alpha = alpha / pi *180;",
"summary":"  converts values in radians to values in degree"
},
{
"code":"function [b b0] = circ_skewness(alpha, w, dim) \n if nargin < 3 \n  dim = 1; \n end \n if nargin < 2 || isempty(w) \n w = ones(size(alpha)); \n else \n if size(w,2) ~= size(alpha,2) || size(w,1) ~= size(alpha,1)  \n error('Input dimensions do not match'); \n   end  \n end \n R = circ_r(alpha,w,[],dim); \n theta = circ_mean(alpha,w,dim); \n [~, rho2 mu2] = circ_moment(alpha,w,2,true,dim); \n theta2 = repmat(theta, size(alpha)./size(theta)); \n b = sum(w.*(sin(2*(circ_dist(alpha,theta2)))),dim)./sum(w,dim); \n b0 = rho2.*sin(circ_dist(mu2,2*theta))./(1-R).^(3/2);    % (formula 2.29) ",
"summary":"Calculates a measure of angular skewness"
},
{
"code":"function out = compq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = cell(size(X)); \n for i = 1:c \n mat{i} = compq(X{i}); \n end \n elseif string(class(X)) ~= 'cell \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = zeros(size(X)); \n for i = 1:c \n if imag(X(i)) ~= 0 & real(X(i)) ~= 0 & string(class(X)) ~= 'sym' \n mat(i) = true; \n elseif imag(X(i)) == 0 | real(X(i)) == 0 | string(class(X)) == 'sym' \n mat(i) = false; \n end \n end \n end \n out = mat; \n end",
"summary":"checks to see if the given number is a complex number."
},
{
"code":"function out = evenq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = cell(size(X)); \n for i = 1:c \n mat{i} = evenq(X{i}); \n end \n elseif string(class(X)) ~= 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = zeros(size(X)); \n for i = 1:c \n if imag(X(i)) == 0 \n if mod(X(i),2) == 0 \n mat(i) = true; \n elseif mod(X(i),2) ~= 0 \n mat(i) = false; \n end \n elseif imag(X(i)) ~= 0 \n mat(i) = false; \n end \n end \n end \n out = mat; \n end",
"summary":"checks to see if the given number is even."
},
{
"code":"function out = imagq(X)\n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i);\n     end \n mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = imagq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     im = sqrt(-1); \n    c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i))*im == X(i) \n             mat(i) = true; \n         elseif imag(X(i))*im ~= X(i) \n             mat(i) = false; \n         end \n     end \n out = mat; \n end",
"summary":"checks to see if the given number is an imaginary number."
},
{ 
"code":"function out = intq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = intq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i)) == 0 \n             if mod(X(i),2) == 1 | mod(X(i), 2) == 0  \n                 mat(i) = true; \n             elseif mod(X(i),2) ~= 1 & mod(X(1),2) ~= 0 \n                 mat(i) = false;  \n             end \n         elseif imag(X(i)) ~= 0 \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"summary":"checks to see if the given number is an integer."
},
{
"code":"function out = oddq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = oddq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i)) == 0 \n             if mod(X(i),2) == 1 \n                 mat(i) = true; \n             elseif mod(X(i),2) ~= 1 \n                 mat(i) = false; \n             end \n         elseif imag(X(i)) ~= 0 \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"summary":"checks to see if the given number is odd."
},
{
"code":"function out = realq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = realq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X));  \n     for i = 1:c \n         if real(X(i)) == X(i) \n             mat(i) = true; \n         elseif real(X(i)) ~= X(i) \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"summary":"checks to see if the given number is a real number."
},
{
"code":"function out = symq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = symq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n    mat = zeros(size(X)); \n     for i = 1:c \n         if string(class(X(i))) == 'sym' \n             mat(i) = true; \n         elseif string(class(X(i))) ~= 'sym' \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"summary":"checks to see if the given input is a symbol."
},
{
"code":"function [X,Y]=ellipse(T, ax, ay, t0); \n X=ax*cos(T);   \n Y=ay*cos(T-t0);",
"summary":"Function Defining an Ellipse"
},
{
"code":"format long \n x=0.4,  s=sin(x)  \n a1=asin(s),  a2=pi-a1,  a3=a1-2*pi,  a4=a1+2*pi \n s1=sin(a1),  s2=sin(a2),  s3=sin(a3),  s4=sin(a4)",
"summary":"Test of angles corresponding to sin(x)"
},
{
  "code": "format long \n disp('The two sides and the angle:') \n a=4.1,  b=9.1,  A=20/180*pi   \n disp('Use the sine theorem to obtain sin(B), then B and C')  \n sB=b*sin(A)/a,  B=asin(sB),  C=pi-A-B \n disp('Calculate the side c by the sine theorem') \n c=a*sin(C)/sin(A) \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180 \n disp('Repeat to find the second solution') \n a=4.1,  b=9.1,  A=20/180*pi \n sB=b*sin(A)/a,  B=pi-asin(sB),  C=pi-A-B \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180",
  "summary": "Triangle with Two Sides and One Angle Known"
},
{
"code":"x0=5;  X=-x0:0.01:x0; \n Y1=sin(X);  Y2=cos(X);  Y3=tan(X);  Y4=cot(X);  \n figure(1),  plot(X,Y1,  X,Y2,  X,Y3,  X,Y4),  grid on \n y0=3; \n axis([-x0 x0 -y0 y0]) \n title('Trigonometric Functions'),  xlabel('x'),  ylabel('sin(x), cos(x), etc.') \n legend('sin(x)', 'cos(x)', 'tan(x)', 'cot(x)') ",
"summary":"Plot Trigonometric Functions"
},
{
"code":"x0=1;  X=-x0:0.01:x0;  \n Y1=acos(X);  Y2=atan(X);   \n figure(1),  plot(X,Y1, X,Y2),  grid on \n y0=2*pi;  \n axis([-x0 x0 -y0 y0]) \n title('Inverse Functions'),  xlabel('x'),  ylabel('acos(x), atan(x)') \n legend('acos(x)', 'atan(x)') ",
"summary":" Inverse Trigonometric Functions"
},
{
"code":"x0=2*pi;  X=-x0: 0.01: x0;  \n Y1=cos(X);  Y2=tan(X);  \n figure(1),  plot(Y1,X, Y2,X),  grid on \n y0=2*pi;   \n axis([-x0 x0 -y0 y0]) \n title('Inverse Functions'),  xlabel('x'),  ylabel('acos(x), atan(x)') \n legend('acos(x)', 'atan(x)')  \n ",
"summary":"Inverse Trigonometric Functions by Swapping "
},
{
"code":"x0=10;  X=-x0:0.01:x0; \n Y1=exp(X);  Y2=1e3*exp(X);  Y3=1e6*exp(X);     \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Exponential functions'),  xlabel('x'),  ylabel('exp(x), etc.') \n legend('exp(x)', '1e3*exp(x)', '1e6*exp(x)') \n axis([-x0 x0 0 2.5e4])",
"summary":"Plot Exponential Functions"
},
{ 
"code":"% x0=10;  X=0.01: 0.01: x0;   \n Y1=log(X);  Y2=log(1e3*X);  Y3=log(1e6*X);  \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Logarithmic functions'),  xlabel('x'),  ylabel('log(x), etc.') \n legend('ln(x)', 'ln(1e3*x)', 'ln(1e6*x)')",
"summary":"Plot  Logarithmic Functions"
},
{
"code":"x0=100;  X=-x0: 0.1: x0; \n Y=exp(X);   \n figure(1),  semilogy(X,Y),  grid on \n title('Exponential function'),  xlabel('x'),  ylabel('exp(x)')",
"summary":" Plot Exponential Functions"
},
{ 
"code":"x0=5;  X=-x0: 0.01: x0; \n Y1=exp(-X.^2);  Y2=exp(-3*X.^2);     \n figure(1),  semilogy(X,Y1,  X,Y2),  grid on \n title('Gaussian functions'),  xlabel('x'),  ylabel('exp(-x^2), exp(-3x^2)')legend('exp(-x^2)',  'exp(-3x^2)')",
"summary":"Plot Gaussian Functions"
},
{
"code":"X=-3: 0.01: 3;  Y1=gaussian(X,1);  Y2=gaussian(X,0.2); \n figure(1),  plot(X,Y1,  X,Y2),  grid on,  title('Gaussians') \n legend('a=1.0', 'a=0.2')",
"summary":"Plot  two Gaussians "
},
{
"code":"theta=0: 1e-3: 2*pi; figure(1);  polar(theta, sin(theta));  \n figure(2);  polar(theta, cos(theta));   \n rho3=cos(4*theta); \n figure(3);  polar(theta, rho3);   \n rho4=1+0.3*cos(8*theta); \n figure(4);  polar(theta, rho4);  \n figure(5);  polar(theta, pi*theta,'r'); \n theta=0: 1e-3: 6*pi; \n figure(6);  polar(theta, pi*theta,'r'); \n figure(7);  polar(theta, exp(0.05*theta),'r'); ",
"summary":" Plots in Polar Coordinates"
},
{
"code":"T= 0:1e-3:2*pi; \n [X1,Y1]=ellipse(T, 2, 1, 0);  \n [X2,Y2]=ellipse(T, 2, 1, pi/3);  \n [X3,Y3]=ellipse(T, 2, 1, pi/2);   \n figure(1);  plot(X1,Y1,  X2,Y2,  X3,Y3);  grid on;  axis equal; \n title('Ellipses'); \n legend('t0=0', 't0=pi/3', 't0=pi/2'),  xlabel('x'),  ylabel('y')  ",
"summary":"Plot of Ellipses"
},
{
"code":"f=inline('x^3- 2*x^2- x+2'); \n figure(1),  fplot(f, [-2 3]),  grid on,  zoom on \n    title('x^3-2*x^2-x+2'),  xlabel('x')",
"summary":"Plot a Cubic Polynomial "
},
{
"code":" clear all \n X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X))/ h; \n figure(1),  plot(X,Y,  X,Der),  grid on, \n    legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
"summary":" Plot a Function and its Derivative   "
},
{
"code":"clear all \n X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n figure(1),  plot(X,Y,  X,Der),  grid on,   \n    legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
"summary":"Plot a Function and its Symmetric Derivative  "
},
{
"code":"  clear all \n X=0:0.01:10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n Der2=(xcos(X+h)-2*xcos(X)+xcos(X-h))/h^2; \n figure(1),  plot(X,Y,  X,Der,  X,Der2),  grid on,  xlabel('x')  \n    legend('f=x*cos(x)', 'df/dx', 'd2f/dx2') \n D2ex=-sin(X)- sin(X)- X.*cos(X); \n figure(2),  plot(X,Der2,  X,D2ex),  grid on \n legend('d2f/dx2', 'exact') \n figure(3),  plot(X,Der2-D2ex),  grid on,  title('Error in d2f/dx2')",
"summary":" Plot Second-Order Derivative"
},
{
"code":"clear all,  format long \n k=input('k= (e.g. 2) '); \n si=0; \n for i=1:20 \n    term=k^(i-1); \n    si=si+term; \n    si_ex=(1-k^i)/(1-k); \n    sums=[si  si_ex],  pause \n end",
"summary":"Sum of a Geometric Series"
},

{
"code":"clear all,  format long; \n x=input('x= (e.g. 1) '); \n term=x;  s=x;  i=0; \n while 1==1 \n    i=i+1; \n    term=term*(-x^2)/(2*i+1)/(2*i); \n    s=s+ term; \n    if abs(term)<1e-15;  break;  end; \n end \n last_index_in_sum=i \n sum=s,  sin_ex=sin(x) \n format short e,  error=s- sin(x)",
"summary":"Power Series for sin(x)"
},
{
"code":"clear all,  format long \n xn=input('xn= (e.g. 1) '); \n x1=0;  n=500; \n h=(xn-x1)/n; \n X=x1: h: xn-h; \n F=cos(X); \n integral=sum(F)* h; \n int_ex=sin(xn)-sin(x1); \n integrals=[integral  int_ex] \n format short e,  error=integral-int_ex",
"summary":"Integration by Direct Summing"
},
{
"code":"clear all \n rand('seed',sum(100*clock)) \n n=5000; \n X=2*(rand(1,n)-0.5);  \n figure(1),  hist(X,10);  grid on \n   title('Number of Random Values in Each Container') ",
"summary":" Histogram of symmetric random numbers   "
},
{
"code":"clear all \n rand('seed',sum(100*clock)) \n while 1==1 \n    head=ceil(rand-0.5) \n    pause \n end",
"summary":" Tossing Coins   "
},
{
"code":"clear all \n m0=100; \n sdev=sqrt(m0)/2; \n for j=1:m0+1 \n    m=j-1; \n    Xm(j)=m; \n    Ybd(j)=prod(1:m0)/prod(1:m)/prod(1:(m0-m))*0.5^m0; \n    Nd(j)=1/sdev/sqrt(2*pi)* exp(-(m- m0/2)^2/2/sdev^2); \n end \n figure(1),  plot(Xm,Ybd,'g',  Xm,Nd,'k:'),  grid on,  axis([0 100 0 0.09]) \n    title('Binomial and Normal Distributions') \n    xlabel('number of heads'),  ylabel('probability') \n figure(2),  plot(Xm,Ybd-Nd),  grid on,  axis([0 100 0 3e-4]);",
"summary":" Binomial and Normal Distributions  "
},
{
"code":"clear all \n P=1: 1e-3: 2;  np=length(P); \n for i=1:np \n    F(i)=sdev(P(i)); \n end \n figure(1),  plot(P,F),  grid on,  xlabel('p'),  ylabel('sdev')",
"summary":" Standard Deviation to Minimize"
},
{
"code":"clear all \n T=[200  250  300  350  400]; \n I=[0.1176    0.0926    0.0735    0.0711    0.0594]*1e-7; \n P=1.5e-6: 5e-9: 3.5e-6; % Values of p for plot \n n=length(P); \n for i=1:n \n    F(i)=ssq1( P(i), T, I); \n end \n figure(2),  plot(T,I,'o',  T,2.34e-6./T),  grid on,  xlabel('temperature')   \n ",
"summary":"Minimize Standard Deviation, Plot Result"
},
{
"code":"function F= fun_fourier(T); \n F=exp(T);",
"summary":"Function for Fourier Series Expansion"
}


]